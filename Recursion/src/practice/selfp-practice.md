## 自测题

# 1，写递归的void输出，跳过 n 行输出，这里 n 是一个正整数，使用System.out.println()跳过一行。

# 2，描述递归算法，画指定数目的同心圆。最内圈的圆 应该有 给定的直径。
其他每个 圆的直径 应该 是其内侧紧邻它的圆 的直径的4/3倍。

# 5，假定 数组的两部分中 都不含有 中间元素。这样，你可以递归地 显示左半部分，
显示中间元素，然后在递归地 显示右半部分。如果这样修改，则如何实现。

# 7，7.3节给出 sumOf 方法的大O 表示 是什么？
    sumOf(6) = sumOf(5) + 6 = 21
    sumOf(5) = sumOf(4) + 5 = 15
    sumOf(4) = sumOf(3) + 4 = 10
    sumOf(3) = sumOf(2) + 3 = 6
    sumOf(2) = sumOf(1) + 2 = 3
    sumOf(1) = 1
令 t(n) 表示 sumOf 的时间需求，
则 以上 讨论的 结果可写为
    t(1) = 1
    当 n > 1:
    t(n) = n + t(n-1)
    t(n-1) = n - 1 + t(n-2)
    t(n-2) = n - 2 + t(n-3)
           .
           .
           .
    t(2) = n - (n - 1) + t(1)
    t(n) = n + (n - 1) + (n - 2) + ... + 1 =  n * (n + 1) / 2

    证明：
        t(1) = 1;
        对任意的 n >= 1 时，
        t(n) = n * (n + 1) / 2;

        可以知道 n=k 时，t(k) = k * (k + 1) / 2 成立
        所以 sumOf(n) 的 时间表示 为 O(n^2)

# 8，对某个实数 x 及整数幂次 n>=0，计算 x^n 时 有一个简单的递归解法：
    x^n = x * x^(n-1)
    x^0 = 1
    a，描述 这个算法时间需求的递推关系是什么？
    b，求解 这个递推关系，找到这个算法的 大O表示？

答：
x^0 = 1
x^1 = x
x^2 = x * x
令 t(n) 表示
    x^n = x * x^(n-1) 时间需求。
    t(1) = 1
    t(2) = 2
        .
        .
        .
    t(n) = 1 + t(n-1)
    可以假设 在 n >= 1时，有 t(n) = n存在；
那么可以知道
    当n = k 时
    t(k) = t(k-1) + 1 = k - 1 + 1 = k
    所以可知当  n > 1 时 有 t(n) = n; 那么其算法的时间复杂的为O(n)


# 9，使用
    x^n = (x^(n/2))^2
    x^n = x(x^((n-1)/2))^2
    x^0 = 1
表示 递归调用 次数的递推关系，也就是 计算 x^n 的方法 的 时间需求
    t(n) = 1 + t(n/2) 当 n>=2 时；
    在 t(0) = 1;
       t(1) = 1;
       t(2) = 1 + t(1) = 2;
       t(4) = 1 + t(2) = 3;
       t(8) = 1 + t(4) = 4
       t(16) = 1 + t(8) = 5;

展开
    t(16) = 1 + t(8) = 1 + 1 + t(4) = 1 + 1 + 1 + t(2) = 4 + t(1);
    t(8) = 1 + t(4) = 3 + t(1);
    t(4) = 1 + t(2) = 2 + t(1);
    t(2) = 1 + t(2) = 1 + t(1);
    ...
    猜想：
    t(n) = 1 + log2(n);
    存在 n=1 时 t(1) = 1
    那么假设，对于所有的 n < k 都有t(n) = 1 + log2(n);
    且 t(k/2) = 1 + log2(k/2);
    t(k) = 1 + t(k/2)
         = 1 + 1 + log2(k/2)
         = log2(4) + log2(k/2)
         = log2(4k/2) = log2(2k) = log2(2) + log2(k) = 1 + log2(k)
    可知：
    存在 t(k) = 1 + log2(k)
    那么，假定对所有 n<k，有 t(n) = 1 + log2(n)，表明 t(k) = 1 + log2(k)
    可知 n>=1 时，存在t(n) = 1 + log2(n);


