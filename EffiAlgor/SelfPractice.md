自测题：
    
    1，对于任意的正整数n，证明：
    1+2+3+...+n = n(n+1)/2；
    答：1+2+3+...+n = 1 + n-1 + 2 + n-2 + 3 + n-3 + ... + 1 = n * n+1 /2 

    2，说明3n^2 + 2^n 是O(2^n)的，说明使用的c 和 N；
    答：
        n = 1, 3 + 2
        n = 2, 12 + 4
        n = 3, 27 + 8
        n = 4, 48 + 16
        n = 5, 75 + 32
        n = 6, 108 + 64
        n = 7, 147 + 128
        n = 8, 192 + 256
        可知道： n >= 8，3n^2 + 2^n < 2 * 2^n = 2 2^n
        选取c = 2，N = 8，可知  3n^2 + 2^n 是O(2^n)的  
    
    3，如果对于 k>0 且 n>0，Pk(n)=a0n^k + a1n^k-1 + ... + ak，求O(Pk(n))
       答：
        O(pk(n)) = O(a0n^k + a1n^k-1 + ... + ak);
        O(max(a0n^k + a1n^k-1 + ... + ak)) = O(n^k)
    
    4，使用大符号O，下列计算的时间需求是多少阶？
        '''
        for i =1 to n
        {
            for j = 1 to 5
                sum = sum +1
        }
        '''
       答：O(n + 5) = O(n);
       
    5，假定对某个确定规模的的给定问题，可用O(n)算法在时间t内求解。
       如果问题规模增大一倍，如果在同样时间内求解这个问题，则计算机需要多快？
    答：2t   
       
    6，使用O(n^2)算法重做前一个问题。
    答：4t
    
    7，下列算法寻找数组前n个元素中是否含有重复的项，最坏情况下，这个算法的大O表示什么？
        '''
        for index = 0 to n-2
            for rest = index+1 to n-1
                if(array[index] equals array[rest])
                    return true;
        return false;
        '''
    答：O((n-2) * (n-1)/2) = O(n^2) 
    
    8，包的remove方法的大O 是多少？ 假定用固定大小的数组表示包，使用一个类似于contains中的参数。
        答：remove和contains的大O一致，最好的情况是O(1)，最差情形和平均情形都是O(n)
    
    9，分析getFrequencyOf()
        答：为O(n)需要遍历整个数组
        
    10，分析toArray()
        答：O(n) 也是遍历然后复制
    
    11，当查找一个不存在包中的项时，方法contains的大O是多少？假定使用链表实现包；
        答：查找不存在项时，即最坏情形，也就是需要遍历整个链表的项 即O(n)
    
    12，包的remove方法的大O 是多少？ 假定用链表表示包，使用一个类似于contains中的参数。
        答：remove和contains的大O一致，最好的情况是O(1)，最差情形和平均情形都是O(n)
    
    13，分析getFrequencyOf()
        答：为O(n)需要遍历整个数组
        
    14，分析toArray()
        答：O(n) 也是遍历然后复制
    
    
    
    
    
    
    
    
       
        
       
                
    
        