# 练习：
  2，描述一种从 楼梯底 爬上 顶层，花费超过O(n^2)时间方法；
     答：

  3，使用 大O符号，表示下列 每个任务 最差情形下的 时间需求。
     a，显示整数数组中的所有整数。
        答：O(n)
     b，显示结点链中的所有整数。
        答：O(n)
     c，显示整数数组中的第n个整数。
        答：O(1)
     d，计算整数数组中前n个偶整数的和。
        答：O(n^2)

  4，使用大O定义，说明：
      a，6n^2 + 3是O(n^2)的
        答：在 n >= 2，时有6n^2 + 3 <= 7n^2
        所以，取c = 7及N = 2时。已说明6n^2 + 3 是 O(n^2)
      b，n^2 + 17n + 1是O(n^2)的
        答：在n>=18 时 n^2 + 17n + 1 <= 2n^2
        所以，取c = 2及N = 18时。已说明n^2 + 17n + 1 是 O(n^2)
      c，5n^3 + 100n^2 - n - 10 是O(n^3)的
        答：在n>=20 时 5n^3 + 100n^2 - n - 10 <= 6n^3 O(n^3)的
      d，3n^2 + 2^n是O(2^n)的
        答：在n>=8 时 3n^2 + 2^n <= 2^(n+1) O(2^n)的

  5，算法 X 需要n^2+9n+5个操作，而算法Y需要5n^2个操作。
  你能给出当n很小时和n很大时，这两个算法的时间需求吗？这两种情况下哪个算法更快。
      答：
      在 n 很小时， n=1，
      则算法 n^2+9n+5 的时间需求是15，
      则算法 5n^2 的时间需求是5。
      在 n 很大时，
      算法 X 的时间 需求是 O(n^2) 的
      算法 Y 的时间 需求也是 O(n^2) 的，两种差不多。

  8，4.2.1节和本章小结说明了典型增长率函数之间的关系，指明下列增长绿函数在这个顺序中的位置。
       a，n^2logn
       b，n^1/2
       c，n^2/logn
       d，n^3
     答：
     由结论可知：
        n^2/logn < n^2logn < n^3
     由因为：
        nlogn < n^2 ==> n < n^2/logn
        n^(1/2) < n < n^2/logn
        可知：
        n^1/2 < n^2/logn < n^2logn < n^3

  9，说明7n^2 + 5n不是O(n)的。
     答：
       由于：在 n >= 1 时，7n^2 + 5n <= 8n^2
       则在 c = 8,N = 2时 7n^2 + 5n 是 O(n^2)
       假设，
            7n^2 + 5n 是 O(n)的，那么：
            有 N 和 c 满足：
                在 n >= N 时，有 7n^2 + 5n <= cn 存在
                   n <= (c-5)/(7)
                   那么可知在n 增大时，将不能保证上述 关系的成立，因此 7n^2 + 5n 不是 O(n)的。

  10，O(n)

  11，O(log2(n))

  12，O(n^2)

  13，O(n^3)

  14，O(n^2)，不是。

  15，O(n)，不是。

  17，根据4.4节，图4-9所示的结论可知
    a，10 + 1
    b，20
    c，40
    d，100

  18，O(n)

  19，O(logn)

  20，
    a，2（1+2+3...+10) = 90
    b，2（1+2+3...+n) = n(n-1)

  21，

  22，add，remove具有常熟阶增长率函数。

  23，
  需要满足 2^n < N，
  则：doubleCapacity 是 O(log2(n))的

  24，
  a，O(n^2):
    for i to n+1
        for j to n
            if (i==j)
                跳出；

  b，O(n):
    （待思考）

  25，
  a，O(n^2):
    （待思考）

  b，O(n):
    复制一个等长度数组，
    使用两个标记位，int negative，positive
    将原数组中的数从数组中取出来和0比较
    如果，
        比0大，放在新数组的高位length - positive，positive++
        比0小，放在新数组的低位length + negative，negative++
    这样只需要比较n次即可。


